generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String        @id @default(cuid())
  email       String        @unique
  name        String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  connections Connection[]
  subscription Subscription?
  playbooks   Playbook[]
}

enum PlanType {
  STARTER
  GROWTH
  PRO
  ENTERPRISE
  TRIAL
}

model Subscription {
  id            String    @id @default(cuid())
  userId        String    @unique
  planType      PlanType  @default(TRIAL)
  status        String    @default("active") // active, cancelled, expired, past_due
  currentPeriodStart DateTime @default(now())
  currentPeriodEnd   DateTime
  canceledAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  // Payment gateway information
  paymentGateway String?  // razorpay, paddle, etc.
  gatewaySubscriptionId String? // Razorpay subscription ID
  gatewayCustomerId String? // Razorpay customer ID
  gatewayPlanId String? // Razorpay plan ID
  metadata     Json? // Additional payment metadata
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  usageRecords  UsageRecord[]
  
  @@index([gatewaySubscriptionId])
  @@index([gatewayCustomerId])
}

model UsageRecord {
  id            String    @id @default(cuid())
  subscriptionId String
  periodStart   DateTime  // Start of billing period
  periodEnd     DateTime  // End of billing period
  emailsSent    Int       @default(0)
  emailsReceived Int      @default(0)
  aiSuggestions Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, periodStart])
  @@index([subscriptionId, periodStart])
}

model Connection {
  id           String         @id @default(cuid())
  type         ConnectionType
  accessToken  String         // OAuth token or custom app access token (encrypted)
  refreshToken String?
  shopDomain   String?
  metadata     Json?          // Can store: storeName, supportEmail, webhookUrl, subdomain, lastWebhookReceived, connectionMethod
  userId       String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  user         User           @relation(fields: [userId], references: [id])
  orders       Order[]
  threads      Thread[]
  customers    Customer[]
  // Note: Messages are related via threads, not directly via connectionId

  @@index([userId])
  @@index([userId, createdAt])
}

// Customer model to store PII data from Shopify webhooks
// Webhooks contain full customer data that Admin API redacts for non-embedded apps
model Customer {
  id            String     @id @default(cuid())
  shopifyId     String     @unique  // Shopify customer ID
  connectionId  String
  email         String?
  phone         String?
  firstName     String?
  lastName      String?
  // Shipping/Billing address fields
  address1      String?
  address2      String?
  city          String?
  province      String?
  provinceCode  String?
  country       String?
  countryCode   String?
  zip           String?
  company       String?
  // Aggregated stats
  ordersCount   Int        @default(0)
  totalSpent    Int        @default(0) // in cents
  acceptsMarketing Boolean @default(false)
  // Timestamps
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  // Relations
  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  orders        Order[]

  @@index([connectionId])
  @@index([email])
  @@index([connectionId, email])
}

model Order {
  id           String     @id @default(cuid())
  shopifyId    String     @unique
  status       String                      // Financial status from Shopify (paid, pending, refunded, etc.)
  fulfillmentStatus String?                // Fulfillment/shipping status (fulfilled, unfulfilled, partial, shipped, in_transit, etc.)
  email        String?
  totalAmount  Int
  currency     String     @default("INR")  // Currency code from Shopify (USD, INR, etc.)
  customerName String?    // Customer full name for display
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  shopDomain   String?
  name         String?
  processedAt  DateTime?  // Time when order was processed by Shopify
  statusUpdatedAt DateTime? // Time when order status was last updated
  connectionId String
  customerId   String?    // Link to Customer (populated from webhooks with full PII)
  actions      Action[]
  messages     Message[]
  lineItems    OrderLineItem[]
  connection   Connection @relation(fields: [connectionId], references: [id])
  customer     Customer?  @relation(fields: [customerId], references: [id])

  @@index([connectionId])
  @@index([connectionId, createdAt])
  @@index([customerId])
}

// Line items for orders - stored for fast display without Shopify API calls
model OrderLineItem {
  id          String   @id @default(cuid())
  orderId     String
  shopifyId   String   // Shopify line_item.id
  title       String
  quantity    Int
  price       Int      // Price in cents
  sku         String?
  variantId   String?
  productId   String?
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@unique([orderId, shopifyId])
}

model Thread {
  id            String     @id @default(cuid())
  subject       String?
  customerEmail String
  isUnread      Boolean    @default(true)
  isFlagged     Boolean    @default(false)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  connectionId  String
  messages      Message[]
  connection    Connection @relation(fields: [connectionId], references: [id])

  @@index([connectionId])
  @@index([isUnread])
  @@index([isFlagged])
}

model Message {
  id           String           @id @default(cuid())
  threadId     String
  orderId      String?
  from         String
  to           String
  body         String
  direction    MessageDirection
  createdAt    DateTime         @default(now())
  headers      Json?
  messageId    String?          @unique
  aiSuggestion AISuggestion?
  // Note: connectionId column does not exist in database, connection is accessed via thread.connectionId
  order        Order?           @relation(fields: [orderId], references: [id])
  thread       Thread           @relation(fields: [threadId], references: [id])

  @@index([direction, createdAt])
  @@index([threadId])
  @@index([threadId, createdAt])  // For thread-based queries with ordering
  @@index([orderId])
  @@index([orderId, createdAt, direction])  // For pending email count calculation
}

model AISuggestion {
  id             String     @id @default(cuid())
  messageId      String     @unique
  reply          String
  proposedAction ActionType
  orderId        String?
  confidence     Float
  createdAt      DateTime   @default(now())
  message        Message    @relation(fields: [messageId], references: [id])
}

model Action {
  id         String       @id @default(cuid())
  orderId    String
  type       ActionType
  status     ActionStatus @default(PENDING)
  payload    Json?
  createdAt  DateTime     @default(now())
  executedAt DateTime?
  order      Order        @relation(fields: [orderId], references: [id])
}

model Event {
  id        String   @id @default(cuid())
  type      String
  entity    String?
  entityId  String?
  payload   Json?
  createdAt DateTime @default(now())
}

model Playbook {
  id                  String            @id @default(cuid())
  userId              String
  name                String
  description         String?
  category            PlaybookCategory
  trigger             Json              // { type: 'shopify_event' | 'email_intent' | 'scheduled', config: {...} }
  conditions          Json              // Array of condition objects
  actions             Json              // Array of action objects
  confidenceThreshold Float             @default(0.8)
  requiresApproval    Boolean           @default(false)
  enabled             Boolean           @default(false)
  isDefault           Boolean           @default(false) // Default playbooks provided by system
  executionCount      Int               @default(0)
  lastExecutedAt      DateTime?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  user                User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  executions          PlaybookExecution[]

  @@index([userId, category])
  @@index([enabled])
}

model PlaybookExecution {
  id          String   @id @default(cuid())
  playbookId  String
  status      String   // pending, approved, executed, rejected, failed
  confidence  Float?
  triggerData Json     // Data that triggered the execution
  result      Json?    // Result of execution
  error       String?
  createdAt   DateTime @default(now())
  executedAt  DateTime?
  playbook    Playbook @relation(fields: [playbookId], references: [id], onDelete: Cascade)

  @@index([playbookId, createdAt])
  @@index([status])
}

enum ConnectionType {
  SHOPIFY
  GMAIL
  CUSTOM_EMAIL
  META_ADS
  GOOGLE_ADS
  GOOGLE_ANALYTICS
}

enum PlaybookCategory {
  REFUND_RETURN
  MARKETING
  FULFILLMENT
  SUPPORT
  INVENTORY
  CUSTOM
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum ActionType {
  REFUND
  CANCEL
  REPLACE_ITEM
  ADDRESS_CHANGE
  INFO_REQUEST
  NONE
}

enum ActionStatus {
  PENDING
  APPROVED
  REJECTED
  EXECUTED
}
